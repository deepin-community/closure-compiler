Author: Thomas Koch <thomas@koch.ro>
Description: Don't run test that needs unpackaged caja
Last-Update: 2013-02-22
Forwarded: not-needed

diff --git a/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java b/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java
deleted file mode 100644
index 6a0723f..0000000
--- a/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java
+++ /dev/null
@@ -1,598 +0,0 @@
-/*
- * Copyright 2010 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp.jsonml;
-
-import com.google.common.base.Preconditions;
-import com.google.javascript.jscomp.Compiler;
-import com.google.javascript.jscomp.CompilerPass;
-import com.google.javascript.jscomp.CompilerTestCase;
-import com.google.javascript.rhino.Token;
-import com.google.javascript.jscomp.jsonml.Writer;
-import com.google.javascript.jscomp.jsonml.JsonML;
-import com.google.javascript.jscomp.jsonml.JsonMLAst;
-import com.google.javascript.jscomp.jsonml.JsonMLUtil;
-
-import com.google.javascript.rhino.Node;
-
-import com.google.caja.parser.js.JsonMLParser;
-
-/**
- * Tests for parsing JsonML to AST and vice versa.
- * @author dhans@google.com (Daniel Hans)
- *
- */
-public class JsonMLConversionTest extends CompilerTestCase {
-
-  @Override
-  public CompilerPass getProcessor(Compiler compiler) {
-    return null; // unused
-  }
-
-  @Override
-  public void setUp() {
-    enableEcmaScript5(true);
-  }
-
-  private void testJsonMLToAstConversion(String js) throws Exception {
-    JsonML jsonml = JsonMLParser.parse(js);
-    Node root = parseExpectedJs(js);
-    Node ast = root.getFirstChild();
-    Preconditions.checkState(ast.getType() == Token.SCRIPT);
-
-    testJsonMLToAstConversion(ast, jsonml, js);
-  }
-
-  private void testJsonMLToAstConversion(Node astRoot, JsonML jsonmlRoot,
-      String js) {
-    Compiler compiler = new Compiler();
-    JsonMLAst ast = new JsonMLAst(jsonmlRoot);
-    Node resultAstRoot = ast.getAstRoot(compiler);
-
-    String explanation = resultAstRoot.checkTreeEquals(astRoot);
-    assertNull("JsonML -> AST converter returned incorect result for " + js
-       + "\n" + explanation, explanation);
-  }
-
-  private void testAstToJsonMLConverstion(Node astRoot, JsonML jsonmlRoot,
-      String js) {
-    JsonML resultJsonMLRoot = (new Writer()).processAst(astRoot);
-    String explanation = JsonMLUtil.compare(resultJsonMLRoot, jsonmlRoot);
-    assertNull("AST -> JsonML converter returned incorrect result for " + js +
-        "\n" + explanation, explanation);
-  }
-
-  private void testConversion(String js) throws Exception {
-    JsonML jsonml = JsonMLParser.parse(js);
-    Node root = parseExpectedJs(js);
-    Node ast = root.getFirstChild();
-    Preconditions.checkState(ast.getType() == Token.SCRIPT);
-
-    testJsonMLToAstConversion(ast, jsonml, js);
-
-    jsonml = JsonMLParser.parse(js);
-    testAstToJsonMLConverstion(ast, jsonml, js);
-  }
-
-  public void testArray() throws Exception {
-    testConversion("[,]");
-    testConversion("[]");
-    testConversion("[function (x) {}]");
-    testConversion("[[], [a, [], [[[]], 1], f([a])], 1];");
-    testConversion("x = [1, 2, 3]");
-    testConversion("var x = [1, 2, 3]");
-    testConversion("[, 1, Object(), , , 2]");
-    testConversion("[{x: 'abc', y: 1}]");
-  }
-
-  public void testArray1() throws Exception {
-    testConversion("[,]");
-  }
-
-  public void testAssignOperators() throws Exception {
-    testConversion("x += 1, x -= 1, x *= 1, x /= 1, x %= 1");
-    testConversion("x |= 1, x ^= x, x &= 0");
-    testConversion("x <<= 1, x >>= 1, x >>>= 1");
-    testConversion("y = x += 1");
-  }
-
-  public void testCalls() throws Exception {
-    testConversion("f()");
-    testConversion("f(1)");
-    testConversion("f('a')");
-    testConversion("f(true)");
-    testConversion("f(null)");
-    testConversion("f(undefined)");
-
-    testConversion("f(a + b)");
-    testConversion("f(g(h(a)) * h(g(u(z('a')))))");
-
-    testConversion("x = f()");
-    testConversion("x = f(1)");
-    testConversion("x = f(a + b)");
-    testConversion("x = f(g(h(a)) * h(g(u(z('a')))))");
-
-    testConversion("String('a')");
-    testConversion("Number(1)");
-    testConversion("Boolean(0)");
-    testConversion("Object()");
-    testConversion("Array('a', 1, false, null, Object(), String('a'))");
-
-    testConversion("(function() {})()");
-    testConversion("(function(x) {})(x)");
-    testConversion("(function(x) {var y = x << 1; return y})(x)");
-    testConversion("(function(x) {y = x << 1; return y})(x)");
-    testConversion("var x = (function(x) {y = x << 1; return y})(x)");
-    testConversion("var x = (function(x) {return x << 1})(x)");
-
-    testConversion("eval()");
-    testConversion("eval('x')");
-    testConversion("x = eval('x')");
-    testConversion("var x = eval('x')");
-    testConversion("eval(Template('foo${bar}baz')); var Template;");
-
-    testConversion("a.x()");
-    testConversion("a[x]()");
-    testConversion("z = a.x()");
-    testConversion("var z = a.x()");
-    testConversion("z = a[x]()");
-    testConversion("z = a['x']()");
-    testConversion("var z = a[x]()");
-    testConversion("var z = a['x']()");
-    testConversion("a.x(y)");
-    testConversion("a[x](y)");
-    testConversion("a['x'](y)");
-    testConversion("a[x](y, z, 'a', null, true, f(y))");
-    testConversion("a['x'](y, z, 'a', null, true, f(y))");
-    testConversion("a[b[c[d]]()].x");
-
-    testConversion("(f())()");
-    testConversion("(f(x))(y)");
-    testConversion("(f = getFn())()");
-  }
-
-  public void testConditionals() throws Exception {
-    testConversion("x ? y : z");
-    testConversion("result = x ? y : z");
-  }
-  public void testDecIncOperators() throws Exception {
-    testConversion("x--");
-    testConversion("--x");
-    testConversion("x++");
-    testConversion("++x");
-    testConversion("var y=x++, z=++x; var s=y--, r=++y;");
-  }
-
-  public void testDelete() throws Exception {
-    testConversion("delete a");
-    testConversion("delete a.x");
-    testConversion("delete a[0]");
-    testConversion("delete a.x[0]");
-  }
-
-  public void testDirectives() throws Exception {
-    testConversion("'use strict'");
-    testConversion("function foo() {'use strict'}");
-    testConversion("'use strict'; function foo() {'use strict'}");
-  }
-
-  public void testDoWhile() throws Exception {
-  //   testConversion("do; while (true)");
-     testConversion("do {} while (true)");
-     testConversion("do {;} while (true)");
-     testConversion("do {} while (f(x, y))");
-     testConversion("do {} while (f(f(f(x, y))))");
-     testConversion("do {} while ((f(f(f(x, y))))())");
-     testConversion("do {2 + 3; q = 2 + 3; var v = y * z;"
-         + "g = function(a) {true; var b = a + 1; return a * a}} while (--x)");
-   }
-
-  public void testFor() throws Exception {
-     testConversion("for (;true;) {;}");
-     testJsonMLToAstConversion("for (i = 0; i < 10; ++i) x++");
-     testConversion("for (i = 0; i < 10; ++i) {x++}");
-     testConversion("for (i = 0; i < 10; ++i) {2 + 3; q = 2 + 3; "
-         + "var v = y * z; g = function(a) {true; var b = a + 1;"
-         + "return a * a}}");
-
-     testConversion("for(;true;) {break}");
-     testConversion("for(i = 0; i < 10; ++i) {if (i > 5) {break}}");
-     testConversion("s: for(i = 0; i < 10; ++i) {if (i > 5) {break s}}");
-     testConversion("for (i = 0;true; ++i) {"
-         + "if (i % 2) {continue} else {var x = i / 3; f(x)}}");
-   }
-
-  public void testForIn() throws Exception {
-    testConversion("for (var i in x) {}");
-    testConversion("for (var i in x) {;}");
-    testConversion("for (var i in x) {f(x)}");
-    testConversion("s: for(var i in x) {if (i > 5) {break s}}");
-    testConversion("for (var i in x) {if (i % 2) {"
-        + "continue} else {var x = i / 3; f(x)}}");
-    testConversion("for (var i in x) {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; return a * a}}");
-
-    testConversion("for (i in x) {}");
-    testConversion("for (i in x) {;}");
-    testConversion("for (i in x) {f(x)}");
-    testConversion("s: for (i in x) {if (i > 5) {break s}}");
-    testConversion("for (i in x) {if (i % 2) {"
-        + "continue} else {var x = i / 3; f(x)}}");
-    testConversion("for (i in x) {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; return a * a}}");
-
-  }
-
-  public void testFunctions() throws Exception {
-    testConversion("(function () {})");
-    testConversion("(function (x, y) {})");
-    testConversion("(function () {})()");
-    testConversion("(function (x, y) {})()");
-    testConversion("[ function f() {} ]");
-    testConversion("var f = function f() {};");
-    testConversion("for (function f() {};true;) {}");
-    testConversion("x = (function (x, y) {})");
-
-    testConversion("function f() {}");
-    testConversion("for (;true;) { function f() {} }");
-
-    testConversion("function f() {;}");
-    testConversion("function f() {x}");
-    testConversion("function f() {x;y;z}");
-    testConversion("function f() {{}}");
-  }
-
-  public void testIfElse1() throws Exception {
-    testConversion("if (true) {x = 1}");
-    testConversion("if (true) {x = 1} else {x = 2}");
-    testConversion("if (f(f(f()))) {x = 1} else {x = 2}");
-    testConversion("if ((f(f(f())))()) {x = 1} else {x = 2}");
-    testConversion("if (true) {x = 1}; x = 1;");
-  }
-
-  public void testLabels() throws Exception {
-    testConversion("s: ;");
-    testConversion("s: {;}");
-    testConversion("s: while(true) {;}");
-    testConversion("s: switch (x) {case 'a': break s;}");
-  }
-
-  public void testLogicalExpr() throws Exception {
-    testConversion("a && b");
-    testConversion("a || b");
-    testConversion("a && b || c");
-    testConversion("a && (b || c)");
-    testConversion("f(x) && (function (x) {"
-        + "return x % 2 == 0 })(z) || z % 3 == 0 ? true : false");
-  }
-
-  public void testMathExpr() throws Exception {
-    testConversion("2 + 3 * 4");
-    testConversion("(2 + 3) * 4");
-    testConversion("2 * (3 + 4)");
-  }
-
-  public void testMember() throws Exception {
-    testConversion("o.x");
-    testConversion("a.b.c");
-    testConversion("a.b.c.d");
-    testConversion("o[x]");
-    testConversion("o[0]");
-    testConversion("o[2 + 3 * 4]");
-    testConversion("o[(function (x){var y = g(x) << 1; return y * x})()]");
-    testConversion("o[o.x]");
-    testConversion("o.x[x]");
-    testConversion("a.b[o.x]");
-    testConversion("a.b[1]");
-    testConversion("a[b[c[d]]].x");
-  }
-
-  public void testNew() throws Exception {
-    testConversion("new A");
-    testConversion("new A()");
-
-    testConversion("new A(x, y, z)");
-    testConversion("new A(f(x), g(y), h(z))");
-    testConversion("new A(x, new B(x, y), z)");
-    testConversion("new A(1), new B()");
-    testConversion("new A, B");
-
-    testConversion("x = new A(a)");
-    testConversion("var x = new A(a, b)");
-    testConversion("var x = new A(1), y = new B()");
-  }
-
-  public void testObject0() throws Exception {
-    // TODO(johnlenz): quoted object literal properties are not noted.
-    // testConversion("({'a':0})");
-    // TODO(johnlenz): numbers are represented as strings
-    // testConversion("({1:0})");
-  }
-
-  public void testObject() throws Exception {
-    testConversion("x = {}");
-    testConversion("var x = {}");
-    testConversion("x = {x: 1, y: 2}");
-    // testConversion("var x = {'2': 1, 'a': 2}");
-    // testConversion("var x = {2: 1, a: 2}");
-    testConversion("x = {x: null}");
-    testConversion("x = {a: function f() {}}");
-    // testConversion("x = {1: function f() {}}");
-    testConversion("x = {a: f()}");
-    // testConversion("x = {1: f()}");
-    testConversion("x = {a: function f() {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; return a * a}}}");
-    // testConversion("x = {1: function f() {2 + 3; q = 2 + 3; var v = y * z; "
-    //    + "g = function(a) {true; var b = a + 1; return a * a}}}");
-    testConversion("x = {get a() {return 1}}");
-    testConversion("x = {set a(b) {}}");
-  }
-
-  public void testOperators() throws Exception {
-    testConversion("x instanceof Null");
-    testConversion("!x instanceof A");
-    testConversion("!(x instanceof A)");
-
-    testConversion("'a' in x");
-    testConversion("if('a' in x) {f(x)}");
-    testConversion("undefined in A");
-    testConversion("!(Number(1) in [2, 3, 4])");
-
-    testConversion("true ? x : y");
-    testConversion("(function() {var y = 2 + 3 * 4; return y >> 1})() ? x : y");
-  }
-
-  public void testReturnStatement() throws Exception {
-    testConversion("x = function f() {return}");
-    testConversion("x = function f() {return 1}");
-    testConversion("x = function f() {return 2 + 3 / 4}");
-    testConversion("x = function f() {return function() {}}");
-    testConversion("x = function f() {var y = 2; "
-        + "return function() {return y * 3}}");
-    testConversion("x = function f() {z = 2 + 3; "
-        + "return (function(z) {return z * y})(z)}");
-  }
-
-  public void testRegExp() throws Exception {
-    testConversion("/ab/");
-    testConversion("/ab/g");
-    testConversion("x = /ab/");
-    testConversion("x = /ab/g");
-    testConversion("var x = /ab/");
-    testConversion("var x = /ab/g");
-    testConversion("function f() {"
-        + "/ab/; var x = /ab/; (function g() {/ab/; var x = /ab/})()}");
-    testConversion("var f = function () {return /ab/g;}");
-  }
-
-  public void testSimplePrograms() throws Exception {
-    testConversion(";");
-    testConversion("1");
-    testConversion("x");
-    testConversion("x=1");
-    testConversion("{}");
-    testConversion("{;}");
-    testConversion("{x=1}");
-    testConversion("x='a'");
-
-    testConversion("true");
-    testConversion("false");
-    testConversion("x=true");
-    testConversion("x=false");
-
-    testConversion("undefined");
-    testConversion("x=undefined");
-
-    testConversion("null");
-    testConversion("x = null");
-
-    testConversion("this");
-    testConversion("2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; return a * a}");
-
-    testConversion("a; b");
-    testConversion("a; b; c; d");
-
-    testConversion("x = function () {}");
-    testConversion("x = function f() {}");
-
-    testConversion("x = function (arg1, arg2) {}");
-    testConversion("x = function f(arg1, arg2) {}");
-
-    testConversion("x = function f(arg1, arg2) {1}");
-    testConversion("x = function f(arg1, arg2) {x}");
-
-    testConversion("x = function f(arg1, arg2) {x = 1 + 1}");
-
-    testConversion("var re = new RegExp(document.a.b.c);"
-        + "var m = re.exec(document.a.b.c);");
-
-  }
-
-  public void testSwitch() throws Exception {
-  testConversion("switch (x) {}");
-  testConversion("switch (x) {case 'a':}");
-  testConversion("switch (x) {case 'a':case 'b':}");
-  testConversion("switch (x) {case 'a':case 'b': x}");
-  testConversion("switch (x) {case 'a':case 'b': {;}}");
-  testConversion("switch (x) {case 'a':case 'b': f()}");
-  testConversion("switch (x) {case 'x': case 'y': {;} case 'a':case 'b': f()}");
-  testConversion("switch (x) {case 'a': f(x)}");
-  testConversion("switch (x) {case 'a': {f()} {g(x)}}");
-  testConversion("switch (x) {case 'a': f(); g(x)}");
-  testConversion("switch (x) {default: ;}");
-  testConversion("switch (x) {default:case 'a': ;}");
-  testConversion("switch (x) {case 'a':case'b':default: f()}");
-  testConversion("switch (x) {default:f(x); g(); case 'a': ; case 'b': g(x)}");
-  testConversion("switch (x) {case 'a': default: {f(x); g(z)} case 'b': g(x)}");
-  testConversion("switch (x) {case x: {;}}");
-}
-
-  public void testType() throws Exception {
-    testConversion("undefined");
-    testConversion("null");
-
-    testConversion("0");
-    testConversion("+0");
-    testConversion("0.0");
-
-    testConversion("3.14");
-    testConversion("+3.14");
-
-    testConversion("true");
-    testConversion("false");
-  }
-
-  public void testThis() throws Exception {
-    testConversion("this");
-    testConversion("var x = this");
-    testConversion("this.foo()");
-    testConversion("var x = this.foo()");
-    testConversion("this.bar");
-    testConversion("var x = this.bar()");
-    testConversion("switch(this) {}");
-    testConversion("x + this");
-  }
-
-  public void testThrow() throws Exception {
-    testConversion("throw e");
-    testConversion("throw 2 + 3 * 4");
-    testConversion("throw (function () {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; return a * a}})()");
-    testConversion("throw f(x)");
-    testConversion("throw f(f(f(x)))");
-    testConversion("throw (f(f(x), y))()");
-  }
-
-  public void testTry() throws Exception {
-    testConversion("try {} catch (e) {}");
-    testConversion("try {;} catch (e) {;}");
-    testConversion("try {var x = 0; y / x} catch (e) {f(e)}");
-    testConversion("try {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; h(q); return a * a}; "
-        + "h(q)} catch (e) {f(x)}");
-
-    testConversion("try {} finally {}");
-    testConversion("try {;} finally {;}");
-    testConversion("try {var x = 0; y / x} finally {f(y)}");
-    testConversion("try {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; h(q); return a * a}; "
-        + "h(q)} finally {f(x)}");
-
-    testConversion("try {} catch (e) {} finally {}");
-    testConversion("try {;} catch (e) {;} finally {;}");
-    testConversion("try {var x = 0; y / x} catch (e) {;} finally {;}");
-    testConversion("try {2 + 3; q = 2 + 3; var v = y * z; "
-        + "g = function(a) {true; var b = a + 1; h(q); return a * a}; h(q)} "
-        + "catch (e) {f(x)} finally {f(x)}");
-  }
-
-  public void testTypeof() throws Exception {
-    testConversion("typeof undefined");
-    testConversion("typeof null");
-    testConversion("typeof 1");
-    testConversion("typeof 'a'");
-    testConversion("typeof false");
-
-    testConversion("typeof Null()");
-    testConversion("typeof Number(1)");
-    testConversion("typeof String('a')");
-    testConversion("typeof Boolean(0)");
-
-    testConversion("typeof x");
-    testConversion("typeof new A()");
-    testConversion("typeof new A(x)");
-    testConversion("typeof f(x)");
-    testConversion("typeof (function() {})()");
-    testConversion("typeof 2 + 3 * 4");
-
-    testConversion("typeof typeof x");
-    testConversion("typeof typeof typeof x");
-  }
-
-  public void testUnaryExpressions() throws Exception {
-    testConversion("!x");
-    testConversion("!null");
-    testConversion("!3.14");
-    testConversion("!true");
-
-    testConversion("~x");
-    testConversion("~null");
-    testConversion("~3.14");
-    testConversion("~true");
-
-    testConversion("+x");
-    testConversion("+null");
-    testConversion("+3.14");
-    testConversion("+true");
-
-    testConversion("-x");
-    testConversion("-null");
-    testConversion("-true");
-
-    testConversion("!~+-z");
-    testConversion("void x");
-    testConversion("void null");
-    testConversion("void void !x");
-    testConversion("void (x + 1)");
-  }
-
-  public void testVarDeclarations() throws Exception {
-    testConversion("var x");
-    testConversion("var x = 1");
-    testConversion("var x = 1 + 1");
-    testConversion("var x = 'a' + 'b'");
-
-    testConversion("var x, y, z");
-    testConversion("var x = 2, y = 2 * x, z");
-
-    testConversion("var x = function () {}");
-    testConversion("var x = function f() {}");
-    testConversion("var x = function f(arg1, arg2) {}");
-
-    testConversion("var x = function f(arg1, arg2) {1}");
-    testConversion("var x = function f(arg1, arg2) {x}");
-    testConversion("var x = function f(arg1, arg2) {x = 2 * 3}");
-
-    testConversion("var x = function f() {var x}");
-    testConversion("var x = function f() {var y = (z + 2) * q}");
-
-    testConversion("var x = function f(a, b) {"
-        + "var y = function g(a, b) {z = a + b}}");
-  }
-
-  public void testWhile() throws Exception {
-     testConversion("while (true) {;}");
-     testConversion("while (true) {f()}");
-     testConversion("while (f(x, y)) {break;}");
-     testConversion("while (f(f(f(x, y)))) {}");
-     testConversion("while ((f(f(f(x, y))))()) {}");
-
-     testConversion("while (x--) {2 + 3; q = 2 + 3; var v = y * z; "
-         + "g = function(a) {true; var b = a + 1; return a * a}}");
-   }
-
-  public void testWith() throws Exception {
-     testConversion("with ({}) {}");
-     testConversion("with ({}) {;}");
-     testConversion("with (x) {}");
-     testConversion("with (x) {f(x)}");
-     testConversion("with ({a: function f() {}}) {f(1)}");
-     testConversion("with ({z: function f() {2 + 3; q = 2 + 3; var v = y * z;"
-         + "g = function(a) {true; var b = a + 1; return a * a}}}) {f(1)}");
-     testConversion("with (x in X) {x++}");
-   }
-}
diff --git a/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java b/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java
deleted file mode 100644
index c8bc663..0000000
--- a/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java
+++ /dev/null
@@ -1,850 +0,0 @@
-/*
- * Copyright 2010 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp.jsonml;
-
-import com.google.javascript.jscomp.jsonml.JsonML;
-import com.google.javascript.jscomp.jsonml.JsonMLUtil;
-import com.google.javascript.jscomp.jsonml.TagAttr;
-import com.google.javascript.jscomp.jsonml.TagType;
-import com.google.javascript.jscomp.jsonml.Validator;
-
-import junit.framework.TestCase;
-
-/**
- * Tests validation of particular JsonML elements.
- *
- * @author dhans@google.com (Daniel Hans)
- */
-public class JsonMLValidationTest extends TestCase {
-
-  // Used for correct statements - error message should be null
-  private void testValidation(String jsonml) throws Exception {
-    JsonML jsonMLRoot = JsonMLUtil.parseString(jsonml);
-    String msg = Validator.validate(jsonMLRoot);
-    if (msg != null) {
-      String errorMsg = String.format(
-          "Validation error for %s.\n Received: %s\n", jsonml, msg);
-    }
-  }
-
-  private void testValidation(String jsonml, String expected)
-      throws Exception {
-    JsonML jsonMLRoot = JsonMLUtil.parseString(jsonml);
-    String msg = Validator.validate(jsonMLRoot);
-    if (!msg.equals(expected)) {
-      String errorMsg = String.format(
-          "Validation error for %s.\n Received: %s\n Expected: %s\n",
-          jsonml, msg, expected);
-      assertEquals(errorMsg, expected, msg);
-    }
-  }
-
-  private void testNotEnoughChildrenValidation(String jsonml, TagType type,
-      int expected, int actual) throws Exception {
-    testValidation(jsonml,
-        String.format(Validator.NOT_ENOUGH_CHILDREN_FMT,
-        type, expected, actual));
-  }
-
-  private void testTooManyChildrenValidation(String jsonml, TagType type,
-      int expected, int actual) throws Exception {
-    testValidation(jsonml,
-        String.format(Validator.TOO_MANY_CHILDREN_FMT,
-        type, expected, actual));
-  }
-
-  private void testWrongChildTypeValidation(String jsonml, TagType type,
-      TagType expected, TagType actual, int index) throws Exception {
-    testWrongChildTypeValidation(jsonml, type, new TagType[] { expected },
-        actual, index);
-  }
-
-  private void testWrongChildTypeValidation(String jsonml, TagType type,
-      TagType[] expected, TagType actual, int index) throws Exception {
-    testValidation(jsonml,
-        String.format(Validator.WRONG_CHILD_TYPE_FMT,
-        index, type, Validator.printList(expected), actual));
-  }
-
-  private void testMissingArgument(String jsonml, TagAttr attr, TagType type)
-      throws Exception {
-    testValidation(jsonml,
-        String.format(Validator.MISSING_ARGUMENT, attr, type));
-  }
-
-  public void testAssignExpr() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['AssignExpr',{'op':'='}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['LiteralExpr',{'type':'number','value':1}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['AssignExpr',{'op':'='}," +
-            "['IdExpr',{'name':'x'}]]",
-        TagType.AssignExpr, 2, 1);
-    testTooManyChildrenValidation("" +
-        "['AssignExpr',{'op':'='}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]," +
-            "['IdExpr',{'name':'z'}]]",
-        TagType.AssignExpr, 2, 3);
-    // missing attribute
-    testMissingArgument("" +
-        "['AssignExpr',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['LiteralExpr',{'type':'number','value':1}]]",
-        TagAttr.OP, TagType.AssignExpr);
-  }
-
-  public void testBinaryExpr() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['BinaryExpr',{'op':'+'}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['LiteralExpr',{'type':'number','value':1}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['BinaryExpr',{'op':'+'}," +
-            "['IdExpr',{'name':'a'}]]",
-        TagType.BinaryExpr, 2, 1);
-    testTooManyChildrenValidation("" +
-        "['BinaryExpr',{'op':'&&'}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]," +
-            "['IdExpr',{'name':'c'}]]",
-        TagType.BinaryExpr, 2, 3);
-    // missing attribute
-    testMissingArgument("" +
-        "['BinaryExpr',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['LiteralExpr',{'type':'number','value':1}]]",
-        TagAttr.OP, TagType.BinaryExpr);
-  }
-
-  public void testCaseValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['Case',{}," +
-            "['IdExpr',{'name':'a'}]]");
-    testValidation("" +
-        "['Case',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['CallExpr',{}," +
-                "['IdExpr',{'name':'foo'}]]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['Case',{}]",
-        TagType.Case, 1, 0);
-  }
-
-  public void testCatchValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['CatchClause',{}," +
-            "['IdPatt',{'name':'e'}]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['CatchClause',{}," +
-            "['IdPatt',{'name':'e'}]]",
-        TagType.CatchClause, 2, 1);
-    // wrong children types
-    testWrongChildTypeValidation("" +
-        "['CatchClause',{}," +
-            "['IdExpr',{'name':'e'}]," +
-            "['BlockStmt',{}]]",
-        TagType.CatchClause, TagType.IdPatt, TagType.IdExpr, 0);
-  }
-
-  public void testConditionalExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ConditionalExpr',{}," +
-           "['BinaryExpr',{'op':'=='}," +
-                "['IdExpr',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-           "['LiteralExpr',{'type':'number','value':0}]," +
-           "['LiteralExpr',{'type':'number','value':1}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['ConditionalExpr',{}," +
-            "['BinaryExpr',{'op':'=='}," +
-                "['IdExpr',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]]",
-        TagType.ConditionalExpr, 3, 1);
-    testNotEnoughChildrenValidation("" +
-        "['ConditionalExpr',{}," +
-            "['BinaryExpr',{'op':'=='}," +
-                "['IdExpr',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-            "['LiteralExpr',{'type':'number','value':1}]]",
-        TagType.ConditionalExpr, 3, 2);
-  }
-
-  public void testCountExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['CountExpr',{'isPrefix':false,'op':'++'}," +
-            "['IdExpr',{'name':'x'}]]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['CountExpr',{'isPrefix':false,'op':'++'}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.CountExpr, 1, 2);
-    // missing attribute
-    testMissingArgument("" +
-        "['CountExpr',{'op':'++'}," +
-            "['IdExpr',{'name':'x'}]]",
-         TagAttr.IS_PREFIX, TagType.CountExpr);
-    testMissingArgument("" +
-        "['CountExpr',{'isPrefix':false}," +
-            "['IdExpr',{'name':'x'}]]",
-        TagAttr.OP, TagType.CountExpr);
-  }
-
-  public void testDataProp() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['DataProp',{'name':'x'}," +
-            "['LiteralExpr',{'type':'number','value':1}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['DataProp',{'name':'x'}]",
-        TagType.DataProp, 1, 0);
-    // missing argument
-    testMissingArgument("" +
-        "['DataProp', {}," +
-            "['LiteralExpr',{'type':'number','value':1}]]",
-        TagAttr.NAME, TagType.DataProp);
-  }
-
-  public void testDeleteExpr() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['DeleteExpr',{}," +
-            "['IdExpr',{'name':'x'}]]");
-    //wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['DeleteExpr',{}]",
-        TagType.DeleteExpr, 1, 0);
-    testTooManyChildrenValidation("" +
-        "['DeleteExpr',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.DeleteExpr, 1, 2);
-  }
-
-  public void testDoWhileStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['DoWhileStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['LiteralExpr',{'type':'boolean','value':true}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['DoWhileStmt',{}]",
-        TagType.DoWhileStmt, 2, 0);
-    testTooManyChildrenValidation("" +
-        "['DoWhileStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}]," +
-            "['LiteralExpr',{'type':'boolean','value':true}]]",
-            TagType.DoWhileStmt, 2, 3);
-  }
-
-  public void testEmptyStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['EmptyStmt',{}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['EmptyStmt',{}," +
-            "['BlockStmt',{}]]",
-        TagType.EmptyStmt, 0, 1);
-  }
-
-  public void testForInStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ForInStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['ObjectExpr',{}]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['ForInStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['ObjectExpr',{}]],",
-        TagType.ForInStmt, 3, 2);
-    testTooManyChildrenValidation("" +
-        "['ForInStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['ObjectExpr',{}]," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}]]",
-        TagType.ForInStmt, 3, 4);
-  }
-
-  public void testForStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ForStmt',{}," +
-            "['AssignExpr',{'op':'='}," +
-                "['IdExpr',{'name':'i'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-            "['BinaryExpr',{'op':'<'}," +
-                "['IdExpr',{'name':'i'}]," +
-                "['IdExpr',{'name':'n'}]]," +
-            "['CountExpr',{'isPrefix':true,'op':'++'}," +
-                "['IdExpr',{'name':'i'}]]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['ForStmt',{}," +
-            "['BinaryExpr',{'op':'<'}," +
-                "['IdExpr',{'name':'i'}]," +
-                "['IdExpr',{'name':'n'}]]," +
-            "['CountExpr',{'isPrefix':true,'op':'++'}," +
-                "['IdExpr',{'name':'i'}]]," +
-            "['BlockStmt',{}]]",
-        TagType.ForStmt, 4, 3);
-    testTooManyChildrenValidation("" +
-        "['ForStmt',{}," +
-            "['AssignExpr',{'op':'='}," +
-                "['IdExpr',{'name':'i'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-            "['BinaryExpr',{'op':'<'}," +
-                "['IdExpr',{'name':'i'}]," +
-                "['IdExpr',{'name':'n'}]]," +
-            "['CountExpr',{'isPrefix':true,'op':'++'}," +
-                "['IdExpr',{'name':'i'}]]," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}]]",
-        TagType.ForStmt, 4, 5);
-  }
-
-  public void testFunctionDeclValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['FunctionDecl',{}," +
-            "['IdPatt',{'name':'f'}]," +
-            "['ParamDecl',{}]]");
-    testValidation("" +
-        "['FunctionDecl',{}," +
-            "['IdPatt',{'name':'f'}]," +
-            "['ParamDecl',{}]," +
-            "['IdExpr',{'name':'foo'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['FunctionDecl',{}," +
-            "['IdPatt',{'name':'f'}]]",
-        TagType.FunctionDecl, 2, 1);
-    // function name not specified
-    testWrongChildTypeValidation("" +
-        "['FunctionDecl',{}," +
-            "['Empty', {}]," +
-            "['ParamDecl',{}]]",
-        TagType.FunctionDecl, TagType.IdPatt, TagType.Empty, 0);
-    // list of formal arguments not specified
-    testWrongChildTypeValidation("" +
-        "['FunctionDecl',{}," +
-            "['IdPatt',{'name':'f'}]," +
-            "['Empty',{}]]",
-        TagType.FunctionDecl, TagType.ParamDecl, TagType.Empty, 1);
-  }
-
-  public void testFunctionExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['FunctionExpr',{}," +
-            "['IdPatt',{'name':'f'}]," +
-            "['ParamDecl',{}]]");
-    testValidation("" +
-        "['FunctionExpr',{}," +
-            "['IdPatt',{'name':'f'}]," +
-            "['ParamDecl',{}]," +
-            "['IdExpr',{'name':'foo'}]]");
-    testValidation("" +
-        "['FunctionExpr',{}," +
-            "['Empty', {}]," +
-            "['ParamDecl',{}]]");
-  }
-
-  public void testIdExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['IdExpr',{'name':'x'}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['IdExpr',{'name':'x'}," +
-            "['BlockStmt',{}]]",
-        TagType.IdExpr, 0, 1);
-    // missing name argument
-    testMissingArgument("" +
-        "['IdExpr', {}]",
-        TagAttr.NAME, TagType.IdExpr);
-  }
-
-  public void testIdPattValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['IdPatt',{'name':'x'}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['IdPatt',{'name':'x'}," +
-            "['BlockStmt',{}]]",
-        TagType.IdPatt, 0, 1);
-    // missing name argument
-    testMissingArgument("" +
-        "['IdPatt', {}]",
-        TagAttr.NAME, TagType.IdPatt);
-  }
-
-  public void testIfStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['IfStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['BlockStmt',{}]," +
-            "['EmptyStmt',{}]]");
-    testValidation("" +
-        "['IfStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['IfStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['BlockStmt',{}]]",
-        TagType.IfStmt, 3, 2);
-  }
-
-  public void testInvokeExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['InvokeExpr',{'op':'.'}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['LiteralExpr',{'type':'string','value':'foo'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['InvokeExpr',{'op':'[]'}," +
-            "['IdExpr',{'name':'x'}]]",
-        TagType.InvokeExpr, 2, 1);
-    // missing attribute
-    testMissingArgument("" +
-        "['InvokeExpr',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['LiteralExpr',{'type':'string','value':'foo'}]]",
-        TagAttr.OP, TagType.InvokeExpr);
-  }
-
-  public void testJmpStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['BreakStmt',{}]");
-    testValidation("" +
-        "['BreakStmt',{'label':'s'}]");
-    testValidation("" +
-        "['ContinueStmt',{}]");
-    testValidation("" +
-        "['ContinueStmt',{'label':'s'}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['BreakStmt',{}," +
-            "['IdExpr',{'name':'s'}]]",
-        TagType.BreakStmt, 0, 1);
-    testTooManyChildrenValidation("" +
-        "['ContinueStmt',{}," +
-            "['IdExpr',{'name':'s'}]]",
-        TagType.ContinueStmt, 0, 1);
-  }
-
-  public void testLabelledStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['LabelledStmt',{'label':'s'}," +
-            "['IdExpr',{'name':'x'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['LabelledStmt',{'label':'s'}]",
-        TagType.LabelledStmt, 1, 0);
-    testTooManyChildrenValidation("" +
-        "['LabelledStmt',{'label':'s'}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.LabelledStmt, 1, 2);
-    // missing attribute
-    testMissingArgument("" +
-        "['LabelledStmt',{}," +
-            "['IdExpr',{'name':'x'}]]",
-        TagAttr.LABEL, TagType.LabelledStmt);
-  }
-
-  public void testLiteralExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['LiteralExpr',{'type':'string','value':'x'}]");
-    testValidation("" +
-        "['LiteralExpr',{'type':'boolean','value':'true'}]");
-    testValidation("" +
-        "['LiteralExpr',{'type':'number','value':'1.0'}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['LiteralExpr',{'type':'number','value':'1.0'}," +
-            "['BlockStmt',{}]]",
-        TagType.LiteralExpr, 0, 1);
-    // missing attribute
-    testMissingArgument("" +
-        "['LiteralExpr',{'type':'string'}]",
-        TagAttr.VALUE, TagType.LiteralExpr);
-    testMissingArgument("" +
-        "['LiteralExpr',{'value':'1.0'}]",
-        TagAttr.TYPE, TagType.LiteralExpr);
-  }
-
-  public void testLogicalExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['LogicalAndExpr',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]]");
-    testValidation("" +
-        "['LogicalOrExpr',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['LogicalAndExpr',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]," +
-            "['IdExpr',{'name':'c'}]]",
-            TagType.LogicalAndExpr, 2, 3);
-    testNotEnoughChildrenValidation("" +
-        "['LogicalAndExpr',{}," +
-            "['IdExpr',{'name':'a'}]]",
-        TagType.LogicalAndExpr, 2, 1);
-  }
-
-  public void testNewExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['NewExpr',{}," +
-            "['IdExpr',{'name':'A'}]," +
-            "['IdExpr',{'name':'x'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['NewExpr',{}]",
-        TagType.NewExpr, 1, 0);
-  }
-
-  public void testObjectExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ObjectExpr',{}]");
-    testValidation("" +
-        "['ObjectExpr',{}," +
-            "['DataProp',{'name':'x'}," +
-                "['LiteralExpr',{'type':'number','value':1}]]," +
-            "['DataProp',{'name':'y'}," +
-                "['LiteralExpr',{'type':'number','value':2}]]]");
-    // wrong types of children
-    TagType[] tags =
-        {TagType.DataProp, TagType.GetterProp, TagType.SetterProp };
-    testWrongChildTypeValidation("" +
-        "['ObjectExpr',{}," +
-            "['DataProp',{'name':'x'}," +
-                "['LiteralExpr',{'type':'number','value':1}]]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.ObjectExpr, tags, TagType.IdExpr, 1);
-  }
-
-  public void testParamDeclValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ParamDecl',{}]");
-    testValidation("" +
-        "['ParamDecl',{}," +
-            "['IdPatt',{'name':'x'}]," +
-            "['IdPatt',{'name':'y'}]]");
-    // wrong types of children
-    testWrongChildTypeValidation("" +
-        "['ParamDecl',{}," +
-            "['IdPatt',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.ParamDecl, TagType.IdPatt, TagType.IdExpr, 1);
-  }
-
-  public void testRegExpExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['RegExpExpr',{'body':'abc','flags':''}]");
-    testValidation("" +
-        "['RegExpExpr',{'body':'abc','flags':'g'}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['RegExpExpr',{'body':'abc','flags':'g'}," +
-            "['IdExpr',{'name':'a'}]]",
-        TagType.RegExpExpr, 0, 1);
-    // missing attribute
-    testMissingArgument("" +
-        "['RegExpExpr',{'body':'abc'}]",
-        TagAttr.FLAGS, TagType.RegExpExpr);
-    testMissingArgument("" +
-        "['RegExpExpr',{'flags':'g'}]",
-        TagAttr.BODY, TagType.RegExpExpr);
-  }
-
-  public void testReturnStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ReturnStmt',{}]");
-    testValidation("" +
-        "['ReturnStmt',{}," +
-            "['LiteralExpr',{'type':'number','value':1}]]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['ReturnStmt',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]]",
-        TagType.ReturnStmt, 1, 2);
-  }
-
-  public void testSwitchStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['SwitchStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['Case',{}," +
-                "['LiteralExpr',{'type':'number','value':1}]," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'foo'}]]]," +
-            "['DefaultCase',{}," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'bar'}]]]]");
-    testValidation("" +
-        "['SwitchStmt',{}," +
-            "['IdExpr',{'name':'x'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['SwitchStmt',{}]",
-        TagType.SwitchStmt, 1, 0);
-    // wrong types of children
-    testWrongChildTypeValidation("" +
-        "['SwitchStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['AssignExpr',{'op': '='}," +
-                "['LiteralExpr',{'type':'number','value':1}]," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'foo'}]]]," +
-            "['DefaultCase',{}," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'bar'}]]]]",
-        TagType.SwitchStmt,
-        new TagType[] { TagType.Case, TagType.DefaultCase },
-        TagType.AssignExpr, 1);
-    testWrongChildTypeValidation("" +
-        "['SwitchStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['DefaultCase',{}," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'foo'}]]]," +
-            "['DefaultCase',{}," +
-                "['CallExpr',{}," +
-                    "['IdExpr',{'name':'bar'}]]]]",
-        TagType.SwitchStmt, TagType.Case, TagType.DefaultCase, 2);
-  }
-
-  public void testThisExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ThisExpr',{}]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['ThisExpr',{}," +
-            "['IdExpr',{'name':'a'}]]",
-        TagType.ThisExpr, 0, 1);
-  }
-
-  public void testThrowStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['ThrowStmt',{}," +
-            "['IdExpr',{'name':'e'}]]");
-    // wrong number of children
-    testTooManyChildrenValidation("" +
-        "['ThrowStmt',{}," +
-            "['IdExpr',{'name':'a'}]," +
-            "['IdExpr',{'name':'b'}]]",
-        TagType.ThrowStmt, 1, 2);
-  }
-
-  public void testTryStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['TryStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['CatchClause',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]]");
-    testValidation("" +
-        "['TryStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['CatchClause',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['TryStmt',{}," +
-            "['CatchClause',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]]",
-        TagType.TryStmt, 2, 1);
-    testTooManyChildrenValidation("" +
-        "['TryStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['CatchClause',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}]]",
-        TagType.TryStmt, 3, 4);
-    // wrong type of children
-    testWrongChildTypeValidation("" +
-        "['TryStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['BlockStmt',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]," +
-            "['BlockStmt',{}]]",
-        TagType.TryStmt,
-        new TagType[] { TagType.CatchClause, TagType.Empty },
-        TagType.BlockStmt, 1);
-    testWrongChildTypeValidation("" +
-        "['TryStmt',{}," +
-            "['BlockStmt',{}]," +
-            "['CatchClause',{}," +
-                "['IdPatt',{'name':'e'}]," +
-                "['BlockStmt',{}]]," +
-            "['IdExpr',{'name': 'x'}]]",
-        TagType.TryStmt, TagType.BlockStmt, TagType.IdExpr, 2);
-  }
-
-  public void testUnaryExprValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['UnaryExpr',{'op':'-'}," +
-            "['IdExpr',{'name':'x'}]]");
-    testValidation("" +
-        "['UnaryExpr',{'op':'!'}," +
-            "['CallExpr',{}," +
-                "['IdExpr',{'name':'f'}]," +
-                    "['IdExpr',{'name':'x'}]]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['UnaryExpr',{'op':'-'}]",
-        TagType.UnaryExpr, 1, 0);
-    testTooManyChildrenValidation("" +
-        "['UnaryExpr',{'op':'+'}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.UnaryExpr, 1, 2);
-    // missing attribute
-    testMissingArgument("" +
-        "['UnaryExpr',{}," +
-            "['IdExpr',{'name':'x'}]]",
-        TagAttr.OP, TagType.UnaryExpr);
-  }
-
-  public void testVarDeclValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['VarDecl',{}," +
-            "['IdPatt',{'name':'x'}]]");
-    testValidation("" +
-        "['VarDecl',{}," +
-            "['InitPatt',{}," +
-                "['IdPatt',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]]");
-    testValidation("" +
-        "['VarDecl',{}," +
-            "['InitPatt',{}," +
-                "['IdPatt',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-            "['IdPatt',{'name':'y'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['VarDecl',{}]",
-        TagType.VarDecl, 1, 0);
-    // wrong type of children
-    testWrongChildTypeValidation("" +
-        "['VarDecl',{}," +
-            "['InitPatt',{}," +
-                "['IdPatt',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':0}]]," +
-            "['IdExpr',{'name':'y'}]," +
-            "['IdPatt',{'name':'z'}]]",
-        TagType.VarDecl,
-        new TagType[] { TagType.InitPatt, TagType.IdPatt },
-        TagType.IdExpr, 1);
-  }
-
-  public void testWhileStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['WhileStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['BlockStmt',{}]]");
-    testValidation("" +
-        "['WhileStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['IdExpr',{'name':'x'}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['WhileStmt',{}," +
-            "['BlockStmt',{}]]",
-        TagType.WhileStmt, 2, 1);
-    testTooManyChildrenValidation("" +
-        "['WhileStmt',{}," +
-            "['LiteralExpr',{'type':'boolean','value':true}]," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.WhileStmt, 2, 3);
-  }
-
-  public void testWithStmtValidation() throws Exception {
-    // correct statement
-    testValidation("" +
-        "['WithStmt',{}," +
-            "['IdExpr',{'name':'x'}]," +
-            "['BlockStmt',{}]]");
-    // wrong number of children
-    testNotEnoughChildrenValidation("" +
-        "['WithStmt',{}," +
-            "['BlockStmt',{}]]",
-        TagType.WithStmt, 2, 1);
-    testTooManyChildrenValidation("" +
-        "['WithStmt',{}," +
-            "['IdExpr',{'name':'A'}]," +
-            "['IdExpr',{'name':'x'}]," +
-            "['IdExpr',{'name':'y'}]]",
-        TagType.WithStmt, 2, 3);
-  }
-}
diff --git a/test/com/google/javascript/jscomp/jsonml/SecureCompilerTest.java b/test/com/google/javascript/jscomp/jsonml/SecureCompilerTest.java
deleted file mode 100644
index 0496348..0000000
--- a/test/com/google/javascript/jscomp/jsonml/SecureCompilerTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2010 The Closure Compiler Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.javascript.jscomp.jsonml;
-
-import com.google.javascript.jscomp.jsonml.SecureCompiler;
-import com.google.javascript.jscomp.jsonml.JsonML;
-import com.google.javascript.jscomp.jsonml.JsonMLUtil;
-import com.google.javascript.jscomp.jsonml.SecureCompiler.Report;
-
-import junit.framework.TestCase;
-
-/**
- * Test class for secure compilation.
- *
- * @author dhans@google.com (Daniel Hans)
- *
- */
-public class SecureCompilerTest extends TestCase {
-
-  // simple correct source
-  // var x = 1; var t = x;
-  private static final String SIMPLE_SOURCE =
-    "['Program',{}," +
-        "['VarDecl',{}," +
-            "['InitPatt',{}," +
-                "['IdPatt',{'name':'x'}]," +
-                "['LiteralExpr',{'type':'number','value':1}]]]," +
-        "['VarDecl',{}," +
-            "['InitPatt',{}," +
-            "['IdPatt',{'name':'t'}]," +
-            "['IdExpr',{'name':'x'}]]]]";
-
-  // syntax error source
-  // missing InitPatt element
-  private static final String SYNTAX_ERROR =
-    "['Program',{}," +
-    "['VarDecl',{}," +
-        "['InitPatt',{}," +
-            "['IdPatt',{'name':'x'}]," +
-            "['LiteralExpr',{'type':'number','value':1}]]]," +
-    "['VarDecl',{}," +
-        "['IdPatt',{'name':'t'}]," +
-        "['IdExpr',{'name':'x'}]]]]";
-
-  private void testSuccess(JsonML source) throws Exception {
-    SecureCompiler compiler = new SecureCompiler();
-    compiler.compile(source);
-    Report report = compiler.getReport();
-    assertTrue(report.isSuccessful());
-    assertEquals(0, report.getErrors().length);
-    assertEquals(0, report.getWarnings().length);
-  }
-
-  private void testError(JsonML source) throws Exception {
-    SecureCompiler compiler = new SecureCompiler();
-    compiler.compile(source);
-    Report report = compiler.getReport();
-    assertFalse(report.isSuccessful());
-  }
-
-  private void testString(String jsonml) throws Exception {
-    JsonML source = JsonMLUtil.parseString(jsonml);
-    testSuccess(source);
-  }
-
-  private void testInvalidString(String jsonml) throws Exception {
-    JsonML source = JsonMLUtil.parseString(jsonml);
-    testError(source);
-  }
-
-  public void testCompilerInterface() throws Exception {
-    testString(SIMPLE_SOURCE);
-    testInvalidString(SYNTAX_ERROR);
-  }
-
-
-}
